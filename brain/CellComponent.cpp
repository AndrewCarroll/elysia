CellComponent::CellComponent(){    //These are default values for a generic neuron    mActivity = 0;    mThreshold = 1;    mDevelopmentStage = 0;    mSignalStrength = 1;    mRandomBranchDeterminer = rand(0,1);}void CellComponent::syncBranchDensity(float parentRandomBranchDeterminer, float parentRandomDepthDeterminer, float baseBranchiness, float tipBranchiness, int currentdepth, float treeDepth) {    branchiness = baseBranchiness;    branches = 0;    assert(branchiness<(1<<23) );//using floats in a manner that will not cooperate with floats after a few millions    size_t childSize=mChildBranches.size();    float roundingError=branchiness-floor(branchiness);    if (parentRandomBranchDeterminer>roundingError) {       branchiness=ceil(branchiness);    }else {       branchiness=floor(branchiness);    }    size_t maxDepth=floor(parentRandomDepthDeterminer);    if (parentRandomDepthDeterminer>treeDepth-floor(treeDepth))      maxDepth=ceil(treeDepth);    if (depth>=maxDepth) {        branchiness=0;    }        branchiness-=childSize;    while(branchiness>0){       mChildBranches.push_back(new Branch(this));       branchiness-=1;    }    while (branchiness<0&&mChildBranches.size()) {       size_t whichDies=rand()%mChildBranches.size();       delete mChildBranches[whichDies];       if (whichDies+1!=mChildBranches.size())            mChildBranches[whichDies]=mChildBranches.back();       mChildBranches.pop_back();    }        for (size_t i=0;i<mChildBranches.size();++i) {        b.syncBranchDensity(parentRandomBranchDeterminer, parentRandomDepthDeterminer, baseBranchiness, TipBranchiness, currentdepth + 1, TreeDepth);    }}